# multisig

Multi signature related functions.

> **VERY IMPORTANT NOTICE**

> Before using these functions, please make sure that you have thoroughly read our [guidelines for multi-signature](https://github.com/iotaledger/wiki/blob/master/multisigs.md). It is of utmost importance that you follow these rules, else it can potentially lead to financial losses.

---

## getKey

Generates the corresponding private key of a seed.

### Input
```
iota.multisig.getKey(seed, index)
```

1. **`seed`**: `String` Tryte encoded seed
2. **`index`**: 'Int' Index of the private key.

### Returns
`String` - private key represented in trytes.


---

## getDigest

Generates the digest value of a key.

### Input
```
iota.multisig.getDigest(seed, index)
```

1. **`seed`**: `String` Tryte encoded seed
2. **`index`**: 'Int' Index of the private key.

### Returns
`String` - digest represented in trytes.

---

## addAddressDigest

This function is used to initiate the creation of a new multisig address. The way that it works is that the first participant of the multi-signature initiates this function with an empty curl state, and then shares the newly generated state with the other participants of the multisig address, who then basically add their key digest. Then finally, once the last co-signer added their digest, `finalizeAddress` can be used to get the actual 81-tryte address value. `validateAddress` can be used to actually validate the multi-signature.

### Input
```
iota.multisig.addAddressDigest(digestTrytes, curlStateTrytes)
```

1. **`digestTrytes`**: `String` digest trytes as returned by `getDigest`
2. **`curlStateTrytes`**: 'String' curl state trytes to continue modifying (which are returned by this function)

### Returns
`String` - curl state trytes


---

## finalizeAddress

Finalizes the multisig address generation process and returns the correct 81-tryte address.

### Input
```
iota.multisig.finalizeAddress(curlStateTrytes)
```

1. **`curlStateTrytes`**: 'String' curl state trytes to continue modifying (which are returned by this function)

### Returns
`String` - curl state trytes


---

## validateAddress

Validates a generated multi-sig address by getting the corresponding key digests of each of the co-signers. The order of the digests is of essence in getting correct results.

### Input
```
iota.multisig.validateAddress(multisigAddress, digests)
```

1. **`multisigAddress`**: `String` digest trytes as returned by `getDigest`
2. **`digests`**: 'Array' array of the key digest for each of the cosigners. The digests need to be provided in the correct signing order.

### Returns
`Bool` - true / false

---

## initiateTransfer

Initiates the creation of a new transfer by generating an empty bundle with the correct number of bundle entries to be later used for the signing process. It should be noted that currently, only a single input (via `inputAddress`) is possible. The `remainderAddress` also has to be provided and should be generated by the co-signers of the multi-signature before initiating the transfer.

### Input
```
iota.multisig.initiateTransfer(inputAddress, remainderAddress, numCosigners, transfers, callback)
```

1. **`inputAddress`**: `String` input address which has sufficient balance and is controlled by the co-signers
2. **`remainderAddress`**: 'String' in case there is a remainder balance, send the funds to this address.
3. **`numCosigners`**: `Int` the number of co-signers for the multi-sig
4. **`transfers`**: `Array` Transfers object
5. **`callback`**: `Function`

### Returns
`Array` - bundle

---

## addSignature

This function is called by each of the co-signers individually to add their signature to the bundle. Here too, order is important. This function returns the bundle, which should be shared with each of the participants of the multi-signature.

### Input
```
iota.multisig.addSignature(bundleToSign, cosignerIndex, inputAddress, key, callback)
```

1. **`bundleToSign`**: `Array` bundle to sign
2. **`cosignerIndex`**: `Int` total order index of the current signer in the multi-signature. Index starts at 0. e.g. If there are 4 co-signers, and you are the 3rd in order to add your signature, then your index is `2`.
3. **`inputAddress`**: 'String' input address as provided to `initiateTransfer`.
4. **`key`**: `String` private key trytes as returned by `getKey`
5. **`callback`**: `Function`

### Returns
`Array` - bundle

---

## validateSignatures

This function makes it possible for each of the co-signers in the multi-signature to independently verify that a generated transaction with the corresponding signatures of the co-signers is valid. This function is safe to use and does not require any sharing of digests or key values.

### Input
```
iota.multisig.validateSignatures(signedBundle, inputAddress, numCosigners)
```

1. **`signedBundle`**: `Array` signed bundle by all of the co-signers
2. **`inputAddress`**: 'String' input address as provided to `initiateTransfer`.
4. **`numCosigners`**: `Int` total number of co-signers

### Returns
`bool` - true / false
